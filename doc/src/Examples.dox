/*!
 * @page examples Examples
 *
 * @note This section is a work-in-progress. Over time we will add
 * flow diagrams for key operations that happen through the API, along
 * with more extensive sample implementations for both @ref host "hosts"
 * and @ref manager "managers". Currently it is limited to illustrating a
 * few common operations that a host of the API may perform.
 *
 * @warning At this stage, until we ship a sample manager
 * implementation, the code for later examples won't actually function.
 *
 * @section examples_api_initialization Initializing the API in a Host
 *
 * This example covers the steps required to initialize the API within a
 * @ref host "'host'" tool, script or application that wishes to
 * interact with an @ref asset_management_system.
 *
 * It makes use of the @ref openassetio.pluginSystem "Plugin System" to
 * discover available @ref PythonPluginSystemManagerPlugin
 * "PythonPluginSystemManagerPlugins".
 *
 * It also includes a bare-minimum example of a
 * @fqref{hostApi.HostInterface} "HostInterface" implementation.
 *
 * @code{.py}
 * from openassetio.log import ConsoleLogger, SeverityFilter
 * from openassetio.hostApi import HostInterface, Manager, ManagerFactory
 * from openassetio.pluginSystem import PythonPluginSystemManagerImplementationFactory
 *
 * class ExampleHost(HostInterface):
 *     """
 *     A minimal host implementation.
 *     """
 *     def identifier(self):
 *         return "org.openassetio.example.host"
 *
 *     def displayName(self):
 *         return "OpenAssetIO Example Host"
 *
 * # For simplicity, use a filtered console logger, this logs to
 * # std::out/err based on the value of FOUNDRY_ASSET_LOGGING_SEVERITY.
 * # Practically you may wish to provide a bridge to your own logging
 * # mechanism if you have one.
 * logger = SeverityFilter(ConsoleLogger())
 *
 * # We need to provide the mechanism by which managers are created, the
 * # built-in plugin system allows these to be loaded from
 * # FOUNDRY_ASSET_PLUGIN_PATH.
 * factory_impl = PythonPluginSystemManagerImplementationFactory(logger)
 *
 * # We then need our implementation of the HostInterface class
 * host_interface = ExampleHost()
 *
 * # We can now create an OpenAssetIO ManagerFactory. The ManagerFactory
 * # allows us to query the available managers, and pick one to talk to.
 * managerFactory = ManagerFactory(host_interface, factory_impl, logger)
 * @endcode
 *
 * @section examples_picking_a_manager Setting up a Manager
 *
 * This example makes use of the newly initialized factory to show how
 * to construct and configure a specific manager (it assumes
 * that some example @ref asset_management_system has a plugin,
 * installed on @ref plugin_path_var).
 *
 * We will be providing an example manager implementation soon!
 *
 * @code{.py}
 * availableManagers = managerFactory.availableManagers()
 * > {
 * >    'org.openassetio.example.manager':
 * >         ManagerFactory.ManagerDetail(
 * >             identifier='org.openassetio.example.manager',
 * >             displayName='Example Asset Manager',
 * >             info={})
 * >    }
 * > }
 *
 * # Once we know which manager we wish to use, we can ask the factory
 * # to create one for us.
 * manager = managerFactory.createManager('org.openassetio.example.manager')
 *
 * # We now have an instance of the requested manager, but it is not
 * # quite ready for use yet. The manager returned by the
 * # ManagerFactory needs to be initialized before it can be used to
 * # query or publish assets. Setup is split into two stages to allow
 * # adjustments to its settings to be made prior to use if required.
 *
 * # A manager's current (or in this case default) settings can be
 * # queried if needed:
 * settings = manager.settings()
 * # ...and updated with new values as desired.
 * settings["server"] = "my.server.com"
 *
 * # Finally, we can initialize the manager with the desired settings,
 * # preparing it for use. Note that this may include non-trivial
 * # amounts of work. Settings updates are sparse, so if you don't have
 * # any custom settings, you can pass an empty dictionary here.
 * manager.initialize(settings)
 * @endcode
 *
 * @section examples_resolving_a_reference Resolving a Reference
 *
 * This example shows how to use the instantiated manager to resolve a
 * string (`some_string`) that may be an entity reference to an entity
 * with the 'file' @ref trait - covering use of the correct context
 * and a custom @ref locale to describe the call site.
 *
 * @note Note how it is the callers responsibility to validate
 * that a string is a @ref entity_reference before passing it to any
 * other OpenAssetIO API that expects one.
 *
 * This is to reduce the validation overhead in the manager's
 * implementation of the API. This affords significant gains in
 * real-world production use cases where thousands of references
 * may be operated upon in time-critical scenarios.
 *
 * The API middleware provides assorted short-circuit validation
 * optimisations that can reduce the number of inter-language hops
 * required. See @fqref{managerApi.ManagerInterface.info}
 * "ManagerInterface.info" and the `kField_EntityReferencesMatchPrefix`
 * key.
 *
 * @code{.py}
 * from openassetio import Context
 * from openassetio import Specification
 *
 * class APIDocumentationExampleLocale(Specification):
 *     """
 *      A locale to represent code run as part of a documentation example
 *     """
 *     kTraitSet = {"documentation", "example"}
 *
 * # We must **ALWAYS** validate that a string is an entity reference
 * # before passing it to any other manager API call.
 * if not manager.isEntityReferenceString(some_string):
 *    raise ValueError(f'"{some_string}" isn't an entity reference.')
 *
 * # All calls to the manager must have a Context, these should always
 * # be created by the target manager. The Context expresses the host's
 * # intent, and ensure that any manager state is properly managed
 * # between API calls.
 * context = manager.createContext()
 *
 * # We describe what we want to do with the asset
 * context.access = context.kRead
 *
 * # We tell the manager something about which part of our code is
 * # working with the asset.
 * context.locale = APIDocumentationExampleLocale.create().traitsData()
 *
 * # We describe the lifetime of the returned reference
 * # as persistent retention may require a more stable value.
 * context.retention = context.kTransient
 *
 * # We can now resolve a token we may have if it is a reference. In
 * # this example, we'll attempt to resolve the asset with the
 * # file trait.
 * [resolved_asset] = manager.resolve([some_string], {FileTrait.id}, context)
 * if resolved_asset.hasTrait(FileTrait.id):
 *    path = FileTrait(resolved_asset).getPath()
 * @endcode
 *
 * @section example_publishing_a_file Publishing a File
 *
 * This example demonstrates how an API host should involve the manager in
 * the creation of new data. In this case, a simple text file.
 *
 * @code{.py}
 * from openassetio import constants
 * from openassetio.traits.managementPolicy import ManagedTrait, WillManagePathTrait
 * from openassetio_mediacreation.specification.entity import TextFileSpecification
 *
 *
 * # As ever, an appropriately configured context is required
 * context = manager.createContext()
 * context.access = context.kWrite
 * context.locale = APIDocumentationExampleLocale.create().traitsData()
 *
 * # The first step is to see if the manager wants to manage text files
 * policy = manager.managementPolicy([TextFileSpecification.kTraitSet], context)[0]
 *
 * if not policy.hasTrait(ManagedTrait.kId):
 *   # The manager doesn't care about this type of asset
 *   return
 *
 * # Not all managers can tell us where to put files (irksome).
 * # The reality of handling this is somewhat more challenging, and
 * # depends on the nature of the task in hand. One for further discussion.
 * save_path = os.path.join(os.path.expanduser('~'), 'greeting.txt')
 * encoding = "utf-8"
 *
 * # Whenever we make new data, we always tell the manager first,
 * # This allows it to create a placeholder version or similar.
 * # NOTE: It is critical to always use the working_ref from now on.
 * working_ref = manager.preflight([entity_ref], TextFileSpecification.kTraitSet, context)[0]
 *
 * # We then check if the manager can tell us where to save the file.
 * if policy.hasTrait(WillManagePathTrait.kId):
 *     working_data = manager.resolve([working_ref], TextFileSpecification.kTraitSet, context)[0]
 *     working_spec = TextFileSpecification(working_data)
 *     save_path = working_spec.locatableContentTrait().getUrl()
 *     encoding_trait = working_spec.textEncodingTrait()
 *     if encoding_trait.isValid() and (custom_encoding := encoding_trait.getEncoding()):
 *         encoding = custom_encoding
 *
 *
 * # Now we can write the file
 * with open(save_path, 'w', encoding=encoding) as f:
 *    f.write("Hello from the documentation example\n")
 *
 * Prepare the entity specification to register, with the data about
 * where we actually wrote the data to, and with what encoding.
 * file_spec = TextFileSpecification.create()
 * file_spec.fileTrait().setPath(save_path)
 * file_spec.textEncodingTrait().setEncoding(encoding)
 *
 * # Now the data has been written, we register the file and the publish
 * # is complete. Update the context retention to denote that we're going
 * # to save a reference to this entity in our user's history.
 * context.retention = context.kPermanent
 * final_ref = manager.register([working_ref], [file_spec.traitsData()], context)[0]
 *
 * # We can persist this reference as we used the kPermanent retention
 * with open(os.path.join(os.path.expanduser('~'), 'history', 'a') as f:
 *     f.write(f"{final_ref}\n")
 * @endcode
 *
 * @section example_generating_a_thumbnail Generating a Thumbnail During Publish
 *
 * This example demonstrates the correct handling in a @ref host of a
 * @needsref WantsThumbnail trait if set by a @ref manager in its
 * @fqref{hostApi.Manager.managementPolicy} "managementPolicy" response.
 *
 * It follows on from the preceding publishing example.
 *
 * @code{.py}
 * # See if the manager wants a thumbnail
 * if not policy.hasTrait(WantsThumbnail.kId):
 *   return
 *
 * from openassetio_mediacreation.specification.entity import ThumbnailFileSpecification
 *
 * # Preflight the thumbnail spec's traits with the target entity's
 * # reference, this gives us a reference we can now use for all
 * # interactions relating to the thumbnail itself.
 * thumbnail_ref = manager.preflight([final_ref], ThumbnailFileSpecification.kTraitSet, context)[0]
 *
 * thumbnail_path = os.path.join(os.path.expanduser('~'), 'greeting.preview.png')
 * thumbnail_attr = {"width": 128, "height": 128}
 *
 * # See if the manager can tell us where to put it, and what it should be like
 * if policy.hasTrait(WillManagePathTrait.kId):
 *     requested = manager.resolve([thumbnail_ref], ThumbnailFileSpecification.kTraitSet, context)[0]
 *     requested_spec = ThumbnailFileSpecification(requested)
 *     file_trait = requested_spec.fileTrait()
 *     if file_trait.isValid() and (requested_path := file_trait.getPath()):
 *         thumbnail_path = requested_path
 *     raster_trait = requested_spec.rasterTrait()
 *     if raster_trait.isValid():
 *         thumbnail_attr["width"] = raster_trait.getWidth() or thumbnail_attr["width"]
 *         thumbnail_attr["height"] = raster_trait.getHeight() or thumbnail_attr["height"]
 *
 * # Generate a thumbnail using the supplied criteria
 * mk_thumbnail(thumbnail_path, thumbnail_attr["width"], thumbnail_attr["height"])
 *
 * # Register the thumbnail to the thumbnail ref (not the entity),
 * # configuring the context to say we're going to ignore the final ref
 *
 * thumbail_spec = ThumbnailFileSpecification.create()
 * thumbnail_spec.fileTrait().setPath(thumbnail_path)
 * raster_trait = thumbnail_spec.rasterTrait()
 * raster_trait.setWidth(thumbnail_attr["width"])
 * raster_trait.setHeight(thumbnail_attr["height"])
 *
 * context.retention = context.kTransient
 * manager.register([thumbnail_ref], [thumbnail_spec.traitsData()], context)
 * @endcode
 */
